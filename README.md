# rabbitmq-order-consume
封装RabbitMQ顺序消费

需要考虑以下问题：
1、mq消费无序主要是由于多个消费同时消费一个队列导致的，如何解决？
> 消息在mq中是有序的，只要控制好消费也是有序即可；   
> 假如一个队列只有一个消费者，在消费完一条消息才能继续消费下一条消息，这样消费就是有序的；

2、假如同类消息只有一个消费者，那如何提高消费的速度？
> 生产者可以选择一组队列中的一个进行发送消息，该组队列中每个队列均只有一个消费者，这样可以有多个线程进行消费，提高消费速度；   
> 举例：订单状态的变化是有序的，假设一共有16个队列，生产者在发送消息给MQ时，可以获取订单ID的hash值，
> 然后通过计算 (16 - 1) & hash 得到应该把消息发送到哪个队列

3、消息堆积，如何提高消费的速度？
> 提高队列的数量，将队列数量作为配置，在需要提高消费速度时增加该配置的值  

4、多节点部署的情况下，如何保证该队列全局只有一个消费者？ 
> 可以通过redis的setnx进行实现   
> 可以通过zookeeper实现（推荐，稍后补充）

5、多节点部署的情况下，如何让消费者均匀分布在不同节点上？
> 1、每个节点启动时，都需要在监听zookeeper中某个路径下新增一个子节点，节点挂掉自动删除zookeeper上对应的节点
> 2、每个节点期望消费者数量=队列数量 / 节点数量 + (队列数量 % 节点数量 == 0 ? 0 : 1)  
> 3、每个节点都需要监听这个路径下的子节点的变化，重新计算每个节点期望的消费者数量  
> 3.1、当前节点消费者数量比期望数量少，向zk注册一个缺少的消费者，如果注册成功，则启动消费者  
> 3.2、当前节点数量比期望数量少，选中多出来的消费者，让其不再消费新的消息，也通知RabbiMQ不再推送新消息到该消费者，
> 然后等消费完成后关闭这些消费者，最后通过zk通知其他节点重启该消费者（即3.1步骤）
> 4、在3.2问中可能会因为队列大小变小，导致队列还有消息未消费，然后就没有消费者了，需要做相应的判断，参考问题8

6、多节点部署的情况下，假如消费者挂掉，如何自动重启消费者并确保全局只有一个消费者？
> 通过zookeeper监听消费者变化，参考上面的流程（待完善）

7、在改变队列大小后未完成的消息如何发送到原来的队列，例如：订单A的状态1已经路由到了队列4，现在队列数量新增，如何确保订单A的状态2还是路由到队列4？
> 使用redis实现  
> 1、在发送消息到队列时，先使用redis的setnx判断是否能设置订单A的队列角标，并设置过期时间  
> 2、假如可以设置成功，则直接找到对应的队列进行发送  
> 3、假如设置失败，说明订单A已经发送过相关消息，直接根据redis中的角标找到对应的队列进行发送  

8、当队列大小被配置成更小的值时，多出来的队列/消费者需要如何处理？因为可能在未来还有消息可能会发往多出来的队列，不能直接销毁队列和消费者
> 1、发送消息：逻辑同问题7  
> 2、有一个定时任务，每隔1分钟去检查多出来的队列中是否有未消费的消息  
> 3、如果没有，则不做处理的  
> 4、如果有，则需要启动一个消费者进行消费，需要将这些消费者均匀的分布在不同节点    
> 5、给这些消费者设定一个最长存活时间，在没有消费消息后的多久，就主动销毁消费者  


